# AuraSR: GAN-based Super-Resolution for real-world, a reproduction of the GigaGAN* paper. Implementation is\n# based on the unofficial lucidrains/gigagan-pytorch repository. Heavily modified from there.\n#\n# https://mingukkang.github.io/GigaGAN/\nfrom math import log2, ceil\nfrom functools import partial\nfrom typing import Any, Optional, List, Iterable\n\nimport torch\nfrom torchvision import transforms\nfrom PIL import Image\nfrom torch import nn, einsum, Tensor\nimport torch.nn.functional as F\n\nfrom einops import rearrange, repeat, reduce\nfrom einops.layers.torch import Rearrange\nfrom torchvision.utils import save_image\nimport math\n\n\n# Helper function to check the existence of an object\ndef exists(x):\n    return x is not None\n\n\n# Helper function to provide a default value if None\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\n# This helps create a checkboard pattern with some edge blending\ndef create_checkerboard_weights(tile_size):\n    x = torch.linspace(-1, 1, tile_size)\n    y = torch.linspace(-1, 1, tile_size)\n\n    x, y = torch.meshgrid(x, y, indexing='ij')\n    d = torch.sqrt(x*x + y*y)\n    sigma, mu = 0.5, 0.0\n    weights = torch.exp(-((d-mu)**2 / (2.0 * sigma**2)))\n\n    # saturate the values to sure get high weights in the center\n    weights = weights**8\n\n    return weights / weights.max()  # Normalize to [0, 1]\n\n
